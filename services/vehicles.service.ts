/**
 * Vehicles Service - REST API Integration
 * Handles vehicle tracking, parking management, and security operations
 */

import { apiClient } from './api.client';
import { APIResponse } from '@/types/api';

// Types for vehicle management
export interface SecurityVehicle {
  id: string;
  vehicleNumber: string;
  registrationNumber: string;
  type: 'car' | 'bike' | 'bicycle' | 'truck' | 'auto' | 'bus' | 'other';
  make?: string;
  model?: string;
  color?: string;
  ownerType: 'visitor' | 'resident' | 'service' | 'delivery' | 'vendor' | 'emergency';
  ownerId: string;
  ownerName: string;
  ownerPhone?: string;
  ownerFlat?: string;
  parkingSpot?: string;
  parkingZone?: string;
  checkInTime: Date;
  checkOutTime?: Date;
  expectedDepartureTime?: Date;
  actualDepartureTime?: Date;
  status: 'parked' | 'departed' | 'overstay' | 'blacklisted' | 'flagged';
  notes?: string;
  registeredBy: string;
  registeredByName?: string;
  securityPhotoUrl?: string;
  licensePhotoUrl?: string;
  vehiclePhotoUrl?: string;
  isRecurring: boolean;
  recurringSchedule?: RecurringSchedule;
  violations: VehicleViolation[];
  alerts: VehicleAlert[];
  gpsTracking?: GPSLocation;
  lastSeen?: Date;
  tags: string[];
  verified: boolean;
  blacklistReason?: string;
  blacklistedAt?: Date;
  blacklistedBy?: string;
}

export interface RecurringSchedule {
  id: string;
  frequency: 'daily' | 'weekly' | 'monthly';
  daysOfWeek?: number[]; // 0-6, 0 = Sunday
  startDate: Date;
  endDate?: Date;
  timeSlots: Array<{
    startTime: string; // HH:MM
    endTime: string; // HH:MM
  }>;
  approvedBy: string;
  notes?: string;
  active: boolean;
}

export interface VehicleViolation {
  id: string;
  vehicleId: string;
  type: 'overstay' | 'wrong_zone' | 'no_permit' | 'blocking' | 'unauthorized' | 'other';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  detectedAt: Date;
  resolvedAt?: Date;
  penaltyAmount?: number;
  penaltyPaid: boolean;
  evidencePhotos: string[];
  handledBy?: string;
  resolution?: string;
  status: 'open' | 'resolved' | 'disputed' | 'waived';
}

export interface VehicleAlert {
  id: string;
  vehicleId: string;
  type: 'overstay_warning' | 'departure_reminder' | 'violation_detected' | 'blacklist_match' | 'security_flag';
  priority: 'low' | 'medium' | 'high' | 'critical';
  message: string;
  createdAt: Date;
  acknowledged: boolean;
  acknowledgedAt?: Date;
  acknowledgedBy?: string;
  actionRequired: boolean;
  autoGenerated: boolean;
}

export interface GPSLocation {
  latitude: number;
  longitude: number;
  accuracy: number; // meters
  timestamp: Date;
  speed?: number; // km/h
  heading?: number; // degrees
  address?: string;
  parkingZone?: string;
}

export interface ParkingZone {
  id: string;
  name: string;
  code: string;
  type: 'visitor' | 'resident' | 'vip' | 'disabled' | 'service' | 'emergency';
  capacity: number;
  occupied: number;
  available: number;
  coordinates: {
    latitude: number;
    longitude: number;
    radius: number; // meters
  };
  restrictions: {
    vehicleTypes: SecurityVehicle['type'][];
    timeSlots: Array<{
      startTime: string;
      endTime: string;
      daysOfWeek: number[];
    }>;
    maxDuration: number; // minutes
    requiresPermit: boolean;
    permitTypes: string[];
  };
  amenities: string[];
  hourlyRate?: number;
  penalties: {
    overstayFine: number;
    unauthorizedParkingFine: number;
  };
  isActive: boolean;
}

export interface VehicleRegistrationRequest {
  registrationNumber: string;
  type: SecurityVehicle['type'];
  make?: string;
  model?: string;
  color?: string;
  ownerType: SecurityVehicle['ownerType'];
  ownerName: string;
  ownerPhone?: string;
  ownerFlat?: string;
  expectedDepartureTime?: string; // ISO string
  parkingZone?: string;
  parkingSpot?: string;
  notes?: string;
  photos?: File[];
  isRecurring?: boolean;
  recurringSchedule?: Omit<RecurringSchedule, 'id' | 'approvedBy'>;
  visitPurpose?: string;
  hostDetails?: {
    name: string;
    flat: string;
    phone: string;
  };
}

export interface VehicleDepartureRequest {
  departureTime?: string; // ISO string, defaults to now
  actualParkingFee?: number;
  fuelLevel?: number; // for service vehicles
  meterReading?: number; // odometer
  condition?: 'good' | 'fair' | 'damaged';
  conditionNotes?: string;
  photos?: File[];
  nextVisitScheduled?: boolean;
  nextVisitDate?: string;
}

export interface VehicleSearchFilters {
  status?: SecurityVehicle['status'] | 'all';
  type?: SecurityVehicle['type'] | 'all';
  ownerType?: SecurityVehicle['ownerType'] | 'all';
  parkingZone?: string | 'all';
  dateFrom?: string;
  dateTo?: string;
  registrationNumber?: string;
  ownerName?: string;
  overstayOnly?: boolean;
  violationsOnly?: boolean;
  recurringOnly?: boolean;
  tags?: string[];
  page?: number;
  limit?: number;
  sortBy?: 'check_in_time' | 'expected_departure' | 'registration_number' | 'owner_name' | 'status';
  sortOrder?: 'asc' | 'desc';
}

export interface VehicleStats {
  total: number;
  parked: number;
  departed: number;
  overstay: number;
  flagged: number;
  blacklisted: number;
  violations: number;
  byType: Record<SecurityVehicle['type'], number>;
  byOwnerType: Record<SecurityVehicle['ownerType'], number>;
  byStatus: Record<SecurityVehicle['status'], number>;
  parkingUtilization: number; // percentage
  averageStayDuration: number; // minutes
  peakHours: Array<{
    hour: number;
    count: number;
  }>;
}

export interface ParkingReport {
  date: string;
  totalVehicles: number;
  peakOccupancy: number;
  averageStayDuration: number;
  revenue: number;
  violations: number;
  overstayIncidents: number;
  byZone: Array<{
    zoneId: string;
    zoneName: string;
    utilization: number;
    revenue: number;
    violations: number;
  }>;
  trendsData: Array<{
    hour: string;
    parked: number;
    departed: number;
    violations: number;
  }>;
}

/**
 * Vehicles Service Class
 */
export class VehiclesService {
  private static instance: VehiclesService;

  public static getInstance(): VehiclesService {
    if (!VehiclesService.instance) {
      VehiclesService.instance = new VehiclesService();
    }
    return VehiclesService.instance;
  }

  /**
   * Get list of vehicles
   */
  async getVehicles(filters?: VehicleSearchFilters): Promise<APIResponse<{
    vehicles: SecurityVehicle[];
    totalCount: number;
    stats: VehicleStats;
  }>> {
    const params = new URLSearchParams();
    
    if (filters?.status && filters.status !== 'all') {
      params.append('status', filters.status);
    }
    if (filters?.type && filters.type !== 'all') {
      params.append('type', filters.type);
    }
    if (filters?.ownerType && filters.ownerType !== 'all') {
      params.append('ownerType', filters.ownerType);
    }
    if (filters?.parkingZone && filters.parkingZone !== 'all') {
      params.append('parkingZone', filters.parkingZone);
    }
    if (filters?.dateFrom) {
      params.append('dateFrom', filters.dateFrom);
    }
    if (filters?.dateTo) {
      params.append('dateTo', filters.dateTo);
    }
    if (filters?.registrationNumber) {
      params.append('registrationNumber', filters.registrationNumber);
    }
    if (filters?.ownerName) {
      params.append('ownerName', filters.ownerName);
    }
    if (filters?.overstayOnly !== undefined) {
      params.append('overstayOnly', filters.overstayOnly.toString());
    }
    if (filters?.violationsOnly !== undefined) {
      params.append('violationsOnly', filters.violationsOnly.toString());
    }
    if (filters?.recurringOnly !== undefined) {
      params.append('recurringOnly', filters.recurringOnly.toString());
    }
    if (filters?.tags && filters.tags.length > 0) {
      params.append('tags', filters.tags.join(','));
    }
    if (filters?.page) {
      params.append('page', filters.page.toString());
    }
    if (filters?.limit) {
      params.append('limit', filters.limit.toString());
    }
    if (filters?.sortBy) {
      params.append('sortBy', filters.sortBy);
    }
    if (filters?.sortOrder) {
      params.append('sortOrder', filters.sortOrder);
    }

    const queryString = params.toString();
    const url = `/security/vehicles${queryString ? `?${queryString}` : ''}`;
    
    return apiClient.get(url);
  }

  /**
   * Get detailed vehicle information by ID
   */
  async getVehicle(vehicleId: string): Promise<APIResponse<SecurityVehicle>> {
    return apiClient.get(`/security/vehicles/${vehicleId}`);
  }

  /**
   * Register new vehicle
   */
  async registerVehicle(data: VehicleRegistrationRequest): Promise<APIResponse<SecurityVehicle>> {
    // If photos are provided, upload them first
    let photoUrls: string[] = [];
    
    if (data.photos && data.photos.length > 0) {
      try {
        const uploadPromises = data.photos.map(file => this.uploadVehiclePhoto(file));
        photoUrls = await Promise.all(uploadPromises);
      } catch (error) {
        console.error('Failed to upload vehicle photos:', error);
        // Continue without photos
      }
    }

    return apiClient.post('/security/vehicles/register', {
      ...data,
      photos: photoUrls,
    });
  }

  /**
   * Mark vehicle as departed
   */
  async markDeparted(
    vehicleId: string, 
    data: VehicleDepartureRequest = {}
  ): Promise<APIResponse<{ message: string; vehicle: SecurityVehicle }>> {
    // If photos are provided, upload them first
    let photoUrls: string[] = [];
    
    if (data.photos && data.photos.length > 0) {
      try {
        const uploadPromises = data.photos.map(file => this.uploadVehiclePhoto(file));
        photoUrls = await Promise.all(uploadPromises);
      } catch (error) {
        console.error('Failed to upload departure photos:', error);
        // Continue without photos
      }
    }

    return apiClient.post(`/security/vehicles/${vehicleId}/depart`, {
      ...data,
      photos: photoUrls,
    });
  }

  /**
   * Update vehicle information
   */
  async updateVehicle(
    vehicleId: string,
    data: Partial<Pick<SecurityVehicle, 'notes' | 'expectedDepartureTime' | 'parkingSpot' | 'tags'>>
  ): Promise<APIResponse<SecurityVehicle>> {
    return apiClient.patch(`/security/vehicles/${vehicleId}`, data);
  }

  /**
   * Flag vehicle for security attention
   */
  async flagVehicle(
    vehicleId: string,
    reason: string,
    priority: VehicleAlert['priority'] = 'medium'
  ): Promise<APIResponse<{ message: string }>> {
    return apiClient.post(`/security/vehicles/${vehicleId}/flag`, {
      reason,
      priority,
    });
  }

  /**
   * Add vehicle to blacklist
   */
  async blacklistVehicle(
    vehicleId: string,
    reason: string,
    duration?: number // days, permanent if not specified
  ): Promise<APIResponse<{ message: string }>> {
    return apiClient.post(`/security/vehicles/${vehicleId}/blacklist`, {
      reason,
      duration,
    });
  }

  /**
   * Remove vehicle from blacklist
   */
  async removeFromBlacklist(
    vehicleId: string,
    reason: string
  ): Promise<APIResponse<{ message: string }>> {
    return apiClient.delete(`/security/vehicles/${vehicleId}/blacklist`, {
      data: { reason }
    });
  }

  /**
   * Report vehicle violation
   */
  async reportViolation(
    vehicleId: string,
    violation: {
      type: VehicleViolation['type'];
      severity: VehicleViolation['severity'];
      description: string;
      photos?: File[];
      penaltyAmount?: number;
      location?: string;
    }
  ): Promise<APIResponse<{ message: string; violation: VehicleViolation }>> {
    // If photos are provided, upload them first
    let photoUrls: string[] = [];
    
    if (violation.photos && violation.photos.length > 0) {
      try {
        const uploadPromises = violation.photos.map(file => this.uploadVehiclePhoto(file));
        photoUrls = await Promise.all(uploadPromises);
      } catch (error) {
        console.error('Failed to upload violation photos:', error);
        // Continue without photos
      }
    }

    return apiClient.post(`/security/vehicles/${vehicleId}/violations`, {
      ...violation,
      photos: photoUrls,
    });
  }

  /**
   * Resolve vehicle violation
   */
  async resolveViolation(
    vehicleId: string,
    violationId: string,
    resolution: {
      status: VehicleViolation['status'];
      resolution: string;
      penaltyWaived?: boolean;
      notes?: string;
    }
  ): Promise<APIResponse<{ message: string }>> {
    return apiClient.post(`/security/vehicles/${vehicleId}/violations/${violationId}/resolve`, resolution);
  }

  /**
   * Get parking zones
   */
  async getParkingZones(): Promise<APIResponse<{
    zones: ParkingZone[];
    totalCapacity: number;
    totalOccupied: number;
    utilizationRate: number;
  }>> {
    return apiClient.get('/security/parking/zones');
  }

  /**
   * Get parking zone details
   */
  async getParkingZone(zoneId: string): Promise<APIResponse<ParkingZone & {
    currentVehicles: SecurityVehicle[];
    recentActivity: Array<{
      vehicleId: string;
      vehicleNumber: string;
      action: 'parked' | 'departed';
      timestamp: Date;
    }>;
  }>> {
    return apiClient.get(`/security/parking/zones/${zoneId}`);
  }

  /**
   * Get vehicle statistics
   */
  async getVehicleStats(
    period?: '24h' | '7d' | '30d'
  ): Promise<APIResponse<VehicleStats & {
    trendsData: Array<{
      date: string;
      parked: number;
      departed: number;
      violations: number;
      revenue: number;
    }>;
    alerts: {
      overstayingNow: number;
      violationsToday: number;
      blacklistMatches: number;
      securityFlags: number;
    };
  }>> {
    const params = period ? `?period=${period}` : '';
    return apiClient.get(`/security/vehicles/stats${params}`);
  }

  /**
   * Get parking reports
   */
  async getParkingReports(
    dateFrom: string,
    dateTo: string
  ): Promise<APIResponse<{
    reports: ParkingReport[];
    summary: {
      totalRevenue: number;
      totalViolations: number;
      averageOccupancy: number;
      peakUtilization: number;
    };
  }>> {
    const params = new URLSearchParams();
    params.append('dateFrom', dateFrom);
    params.append('dateTo', dateTo);

    const queryString = params.toString();
    return apiClient.get(`/security/vehicles/reports?${queryString}`);
  }

  /**
   * Search vehicles by registration or owner
   */
  async searchVehicles(
    query: string,
    filters?: {
      activeOnly?: boolean;
      includeHistoric?: boolean;
      limit?: number;
    }
  ): Promise<APIResponse<{
    vehicles: SecurityVehicle[];
    suggestions: string[];
    matchType: 'registration' | 'owner' | 'both';
  }>> {
    const params = new URLSearchParams();
    params.append('q', query);
    
    if (filters?.activeOnly !== undefined) {
      params.append('activeOnly', filters.activeOnly.toString());
    }
    if (filters?.includeHistoric !== undefined) {
      params.append('includeHistoric', filters.includeHistoric.toString());
    }
    if (filters?.limit) {
      params.append('limit', filters.limit.toString());
    }

    const queryString = params.toString();
    return apiClient.get(`/security/vehicles/search?${queryString}`);
  }

  /**
   * Get vehicle alerts
   */
  async getVehicleAlerts(
    filters?: {
      priority?: VehicleAlert['priority'];
      type?: VehicleAlert['type'];
      acknowledged?: boolean;
      vehicleId?: string;
      limit?: number;
    }
  ): Promise<APIResponse<{
    alerts: VehicleAlert[];
    unacknowledgedCount: number;
    criticalCount: number;
  }>> {
    const params = new URLSearchParams();
    
    if (filters?.priority) params.append('priority', filters.priority);
    if (filters?.type) params.append('type', filters.type);
    if (filters?.acknowledged !== undefined) params.append('acknowledged', filters.acknowledged.toString());
    if (filters?.vehicleId) params.append('vehicleId', filters.vehicleId);
    if (filters?.limit) params.append('limit', filters.limit.toString());

    const queryString = params.toString();
    const url = `/security/vehicles/alerts${queryString ? `?${queryString}` : ''}`;
    
    return apiClient.get(url);
  }

  /**
   * Acknowledge vehicle alert
   */
  async acknowledgeAlert(
    alertId: string,
    notes?: string
  ): Promise<APIResponse<{ message: string }>> {
    return apiClient.post(`/security/vehicles/alerts/${alertId}/acknowledge`, {
      notes,
    });
  }

  /**
   * Bulk operations
   */
  async bulkDeparture(
    vehicleIds: string[],
    departureData?: VehicleDepartureRequest
  ): Promise<APIResponse<{
    successful: string[];
    failed: Array<{ id: string; error: string }>;
  }>> {
    return apiClient.post('/security/vehicles/bulk/depart', {
      vehicleIds,
      departureData,
    });
  }

  async bulkFlag(
    vehicleIds: string[],
    reason: string,
    priority: VehicleAlert['priority'] = 'medium'
  ): Promise<APIResponse<{
    successful: string[];
    failed: Array<{ id: string; error: string }>;
  }>> {
    return apiClient.post('/security/vehicles/bulk/flag', {
      vehicleIds,
      reason,
      priority,
    });
  }

  /**
   * Export vehicle data
   */
  async exportVehicles(
    format: 'csv' | 'xlsx' | 'pdf',
    filters?: VehicleSearchFilters
  ): Promise<APIResponse<{ 
    downloadUrl: string; 
    expiresAt: string;
    fileName: string;
  }>> {
    return apiClient.post('/security/vehicles/export', {
      format,
      filters,
    });
  }

  /**
   * Upload vehicle photo
   */
  private async uploadVehiclePhoto(file: File): Promise<string> {
    const formData = new FormData();
    formData.append('file', file);
    formData.append('type', 'vehicle');

    const response = await apiClient.upload('/uploads/vehicles', formData);
    return response.data.url;
  }

  /**
   * Get real-time vehicle updates via WebSocket (placeholder)
   */
  subscribeToVehicleUpdates(callback: (update: {
    type: 'vehicle_registered' | 'vehicle_departed' | 'overstay_detected' | 'violation_reported';
    vehicle: SecurityVehicle;
    details?: any;
  }) => void): () => void {
    // In a real implementation, this would establish a WebSocket connection
    console.log('WebSocket subscription for vehicle updates established');
    
    // Return cleanup function
    return () => {
      console.log('WebSocket subscription for vehicles cleaned up');
    };
  }

  /**
   * Validate registration number format
   */
  validateRegistrationNumber(regNumber: string): {
    isValid: boolean;
    format: string;
    state?: string;
    error?: string;
  } {
    // Basic validation - in real app, this would be more comprehensive
    const regPattern = /^[A-Z]{2}[\s-]?[0-9]{2}[\s-]?[A-Z]{1,2}[\s-]?[0-9]{1,4}$/i;
    const isValid = regPattern.test(regNumber.replace(/\s/g, ''));
    
    return {
      isValid,
      format: isValid ? regNumber.toUpperCase().replace(/\s/g, '') : '',
      state: isValid ? regNumber.substring(0, 2).toUpperCase() : undefined,
      error: !isValid ? 'Invalid registration number format' : undefined,
    };
  }

  /**
   * Get vehicle history
   */
  async getVehicleHistory(
    vehicleId: string,
    includeViolations: boolean = true
  ): Promise<APIResponse<{
    history: Array<{
      id: string;
      action: string;
      description: string;
      performedBy: string;
      performedAt: string;
      metadata?: any;
    }>;
    visits: Array<{
      checkInTime: Date;
      checkOutTime?: Date;
      duration?: number; // minutes
      parkingZone?: string;
      violations: number;
      notes?: string;
    }>;
    violations: VehicleViolation[];
  }>> {
    const params = new URLSearchParams();
    params.append('includeViolations', includeViolations.toString());

    const queryString = params.toString();
    return apiClient.get(`/security/vehicles/${vehicleId}/history?${queryString}`);
  }
}

// Export singleton instance
export const vehiclesService = VehiclesService.getInstance();

// Export types for use in components
export type {
  SecurityVehicle,
  RecurringSchedule,
  VehicleViolation,
  VehicleAlert,
  GPSLocation,
  ParkingZone,
  VehicleRegistrationRequest,
  VehicleDepartureRequest,
  VehicleSearchFilters,
  VehicleStats,
  ParkingReport,
};